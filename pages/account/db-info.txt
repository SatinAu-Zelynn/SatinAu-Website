Cloudflare D1 数据库代码如下

DROP TABLE IF EXISTS users;
CREATE TABLE users (
id INTEGER PRIMARY KEY AUTOINCREMENT,
email TEXT UNIQUE NOT NULL,
password_hash TEXT NOT NULL,
nickname TEXT,
avatar TEXT,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

PRAGMA foreign_keys = ON;

DROP TABLE IF EXISTS comments;
CREATE TABLE comments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  page_id TEXT NOT NULL,
  user_id INTEGER NOT NULL,
  parent_id INTEGER DEFAULT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE
);

CREATE INDEX idx_comments_page_id ON comments(page_id);
ALTER TABLE comments ADD COLUMN status TEXT DEFAULT 'pending';


Cloudflare Worker 代码如下

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    
    // 设置 CORS 头，允许你的前端访问
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*", // 生产环境请改为 "https://satinau.cn"
      "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      if (path === "/api/auth/register" && request.method === "POST") {
        return await register(request, env, corsHeaders);
      } 
      else if (path === "/api/auth/login" && request.method === "POST") {
        return await login(request, env, corsHeaders);
      } 
      else if (path === "/api/user/me" && request.method === "GET") {
        return await getUserProfile(request, env, corsHeaders);
      }
      else if (path === "/api/user/avatar" && request.method === "POST") {
        return await updateAvatar(request, env, corsHeaders);
      }
      else if (path === "/api/comments" && request.method === "GET") {
        return await getComments(request, env, corsHeaders);
      }
      else if (path === "/api/comments" && request.method === "POST") {
        return await postComment(request, env, corsHeaders, ctx);
      }
      else if (path.startsWith("/api/comments/") && request.method === "DELETE") {
        const id = path.split("/").pop();
        return await deleteComment(request, env, corsHeaders, id);
      }

      return new Response("Not Found", { status: 404, headers: corsHeaders });
    } catch (e) {
      return new Response(JSON.stringify({ error: e.message }), { 
        status: 500, 
        headers: { ...corsHeaders, "Content-Type": "application/json" } 
      });
    }
  }
};

/* ===== 业务逻辑 ===== */

async function register(req, env, cors) {
  const { email, password, nickname, cfToken } = await req.json();
  
  if (!email || !password || !nickname) 
    return error(cors, "Missing fields");

  const ip = req.headers.get('CF-Connecting-IP');
  const isHuman = await validateTurnstile(cfToken, env.TURNSTILE_SECRET_KEY, ip);
  
  if (!isHuman) {
    return error(cors, "Turnstile validation failed (Are you a robot?)", 403);
  }

  // 1. 检查邮箱是否存在
  const exists = await env.DB.prepare("SELECT id FROM users WHERE email = ?").bind(email).first();
  if (exists) return error(cors, "Email already exists", 409);

  // 2. 密码哈希 (PBKDF2)
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const hash = await hashPassword(password, salt);
  const storedPass = `${toHex(salt)}:${toHex(hash)}`; // 格式: salt:hash

  // 3. 插入数据库
  await env.DB.prepare(
    "INSERT INTO users (email, password_hash, nickname) VALUES (?, ?, ?)"
  ).bind(email, storedPass, nickname).run();

  return json(cors, { success: true });
}

async function login(req, env, cors) {
  const { email, password, cfToken } = await req.json();

  const ip = req.headers.get('CF-Connecting-IP');
  const isHuman = await validateTurnstile(cfToken, env.TURNSTILE_SECRET_KEY, ip);

  if (!isHuman) {
    return error(cors, "Turnstile validation failed", 403);
  }
  
  const user = await env.DB.prepare("SELECT * FROM users WHERE email = ?").bind(email).first();
  if (!user) return error(cors, "User not found", 401);

  // 验证密码
  const [saltHex, hashHex] = user.password_hash.split(':');
  const salt = fromHex(saltHex);
  const verifyHash = await hashPassword(password, salt);
  
  if (toHex(verifyHash) !== hashHex) {
    return error(cors, "Invalid password", 401);
  }

  // 生成 Token (这里简单用 Base64 模拟 JWT，生产环境请引入 jose 库签发真实 JWT)
  // 格式: userId.expiryTimestamp.signature(fake)
  const token = btoa(JSON.stringify({ uid: user.id, exp: Date.now() + 86400000 })); 

  return json(cors, { 
    token, 
    user: { id: user.id, nickname: user.nickname, email: user.email, avatar: user.avatar } 
  });
}

async function getUserProfile(req, env, cors) {
  const authHeader = req.headers.get("Authorization");
  if (!authHeader) return error(cors, "Unauthorized", 401);

  try {
    const token = authHeader.split(" ")[1];
    const payload = JSON.parse(atob(token));
    
    if (payload.exp < Date.now()) return error(cors, "Token expired", 401);

    const userId = payload.uid;
    const cacheKey = `user:${userId}`;

    const cachedUser = await env.KV.get(cacheKey, { type: "json" });
    if (cachedUser) {
      const res = json(cors, cachedUser);
      res.headers.set("X-Cache", "HIT");
      return res;
    }

    const user = await env.DB.prepare(
      "SELECT id, nickname, email, avatar, created_at FROM users WHERE id = ?"
    ).bind(userId).first();

    if (user) {
      await env.KV.put(cacheKey, JSON.stringify(user), { expirationTtl: 3600 });
    }

    const res = json(cors, user);
    res.headers.set("X-Cache", "MISS");
    return res;

  } catch (e) {
    return error(cors, "Invalid token", 401);
  }
}

// 获取评论列表
async function getComments(req, env, cors) {
  const url = new URL(req.url);
  const pageId = url.searchParams.get("page_id");
  if (!pageId) return error(cors, "Missing page_id");

  // 尝试从 KV 获取 "公开且已通过" 的评论缓存
  const cacheKey = `comments:public:${pageId}`;
  let publicComments = await env.KV.get(cacheKey, { type: "json" });

  if (!publicComments) {
    // 缓存未命中，查数据库：只查 status = 'approved'
    const results = await env.DB.prepare(`
      SELECT 
        c.id, c.page_id, c.content, c.parent_id, c.created_at, c.user_id, c.status,
        u.nickname, u.avatar
      FROM comments c
      LEFT JOIN users u ON c.user_id = u.id
      WHERE c.page_id = ? AND c.status = 'approved'
      ORDER BY c.created_at DESC
    `).bind(pageId).all();
    
    publicComments = results.results || [];
    // 写入 KV 缓存 (1小时过期，因为有后台审核更新)
    await env.KV.put(cacheKey, JSON.stringify(publicComments), { expirationTtl: 3600 });
  }

  // 检查用户是否登录，如果登录，需合并显示 "我的待审核/未通过评论"
  const user = await verifyToken(req);
  let finalComments = publicComments;

  if (user) {
    const myPendingComments = await env.DB.prepare(`
      SELECT 
        c.id, c.page_id, c.content, c.parent_id, c.created_at, c.user_id, c.status,
        u.nickname, u.avatar
      FROM comments c
      LEFT JOIN users u ON c.user_id = u.id
      WHERE c.page_id = ? AND c.user_id = ? AND c.status != 'approved'
      ORDER BY c.created_at DESC
    `).bind(pageId, user.id).all();

    if (myPendingComments.results && myPendingComments.results.length > 0) {
      // 合并两个数组
      finalComments = [...finalComments, ...myPendingComments.results];
      // 重新按时间倒序排序
      finalComments.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
    }
  }

  const res = json(cors, finalComments);
  // 标记缓存状态供调试
  res.headers.set("X-Cache-Status", user ? "MIXED" : "PUBLIC_KV"); 
  return res;
}


// 发布评论
async function postComment(req, env, cors, ctx) {
  const user = await verifyToken(req); 
  if (!user) return error(cors, "Unauthorized", 401);

  const { page_id, content, parent_id } = await req.json();

  if (!page_id || !content) return error(cors, "Missing fields");
  if (content.length > 1000) return error(cors, "Content too long");

  // 插入数据库，状态默认为 'pending'
  const result = await env.DB.prepare(
    "INSERT INTO comments (page_id, user_id, content, parent_id, status) VALUES (?, ?, ?, ?, 'pending')"
  ).bind(page_id, user.id, content, parent_id || null).run();

  if (!result.success) {
    return error(cors, "Failed to post comment", 500);
  }

  const commentId = result.meta.last_row_id;

  // 使用 ctx.waitUntil 在后台执行 AI 审核，不阻塞当前请求返回
  ctx.waitUntil(performAIModeration(env, commentId, content, page_id));

  // 立即返回新评论数据 (状态为 pending)
  const newComment = await env.DB.prepare(`
    SELECT c.*, u.nickname, u.avatar 
    FROM comments c 
    LEFT JOIN users u ON c.user_id = u.id 
    WHERE c.id = ?
  `).bind(commentId).first();
  
  return json(cors, newComment);
}

// AI 审核逻辑
async function performAIModeration(env, commentId, content, pageId) {
  try {
    console.log(`Starting AI moderation for comment ${commentId}...`);
    
    // 使用 Llama 3 模型
    const model = '@cf/meta/llama-3-8b-instruct';
    
    // System Prompt: 定义 AI 的角色和输出格式
    const systemPrompt = `You are a strict content moderation AI. 
    Task: Analyze the user's comment for hate speech, explicit violence, spam, or severe toxicity.
    Output Rule: You must output ONLY one word.
    If the content is safe, output: APPROVED
    If the content is unsafe, output: REJECTED
    Do not output any explanation.`;

    const response = await env.AI.run(model, {
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Comment content: "${content}"` }
      ]
    });

    // 解析 AI 输出
    let status = 'approved'; // 默认通过，避免 AI 挂了导致所有评论卡死
    
    if (response && response.response) {
      const output = response.response.trim().toUpperCase();
      if (output.includes('REJECTED')) {
        status = 'rejected';
      }
    }

    console.log(`AI decision for comment ${commentId}: ${status}`);

    // 更新数据库状态
    await env.DB.prepare("UPDATE comments SET status = ? WHERE id = ?")
      .bind(status, commentId)
      .run();

    // 如果是通过状态，必须清除 KV 中的公共缓存，这样所有人才能看到新评论
    // 如果是拒绝状态，不需要清缓存（因为本来就没显示）
    if (status === 'approved') {
      await env.KV.delete(`comments:public:${pageId}`);
    }

  } catch (err) {
    console.error("AI Moderation Error:", err);
    // 出错时保持 pending，或者你可以选择自动通过
  }
}

// 删除评论
async function deleteComment(req, env, cors, commentId) {
  const user = await verifyToken(req);
  if (!user) return error(cors, "Unauthorized", 401);

  // 1. 检查评论是否存在以及是否属于该用户
  // 注意：这里多查了一个 page_id，为了清除缓存
  const comment = await env.DB.prepare("SELECT user_id, page_id FROM comments WHERE id = ?").bind(commentId).first();
  
  if (!comment) return error(cors, "Comment not found", 404);
  
  if (comment.user_id !== user.id) return error(cors, "Forbidden", 403);

  try {
    // 2. 执行递归删除
    await env.DB.prepare(`
      WITH RECURSIVE targets(id) AS (
        SELECT id FROM comments WHERE id = ?
        UNION ALL
        SELECT c.id FROM comments c JOIN targets t ON c.parent_id = t.id
      )
      DELETE FROM comments WHERE id IN (SELECT id FROM targets);
    `).bind(commentId).run();

    await env.KV.delete(`comments:public:${comment.page_id}`);

    return json(cors, { success: true });
  } catch (e) {
    return error(cors, "Delete failed: " + e.message, 500);
  }
}

/* ===== 工具函数 ===== */

function json(cors, data) {
  return new Response(JSON.stringify(data), {
    headers: { ...cors, "Content-Type": "application/json" }
  });
}

function error(cors, msg, status = 400) {
  return new Response(JSON.stringify({ error: msg }), {
    status,
    headers: { ...cors, "Content-Type": "application/json" }
  });
}

// 密码加密逻辑 (Web Crypto API)
async function hashPassword(password, salt) {
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]
  );
  return await crypto.subtle.deriveBits(
    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
    key, 256
  );
}

function toHex(buffer) {
  return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function fromHex(hex) {
  return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
}

async function updateAvatar(req, env, cors) {
  // 1. 验证 Token (与 getUserProfile 逻辑相同)
  const authHeader = req.headers.get("Authorization");
  if (!authHeader) return error(cors, "Unauthorized", 401);

  let userId;
  try {
    const token = authHeader.split(" ")[1];
    const payload = JSON.parse(atob(token));
    if (payload.exp < Date.now()) return error(cors, "Token expired", 401);
    userId = payload.uid;
  } catch (e) {
    return error(cors, "Invalid token", 401);
  }

  // 2. 解析 FormData 获取文件
  const formData = await req.formData();
  const file = formData.get('avatar');

  if (!file || !(file instanceof File)) {
    return error(cors, "No file uploaded");
  }

  // 3. 校验大小 (后端二次校验，例如限制 2MB)
  if (file.size > 2 * 1024 * 1024) {
    return error(cors, "File too large (Max 2MB)");
  }

  // 4. 将文件转换为 Base64 DataURI
  // 注意：在生产环境中，大文件建议存入 Cloudflare R2，Base64 存数据库仅适合小文件
  const arrayBuffer = await file.arrayBuffer();
  
  // 防止堆栈溢出的 Base64 转换方式
  let binary = '';
  const bytes = new Uint8Array(arrayBuffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  const base64 = btoa(binary);
  
  const mimeType = file.type || 'image/png';
  const avatarUrl = `data:${mimeType};base64,${base64}`;

  // 5. 更新数据库
  try {
    const result = await env.DB.prepare(
      "UPDATE users SET avatar = ? WHERE id = ?"
    ).bind(avatarUrl, userId).run();

    if (result.meta.changes === 0) {
      return error(cors, "User not found or update failed", 404);
    }

    await env.KV.delete(`user:${userId}`);

    // 6. 返回成功及新的头像地址
    return json(cors, { success: true, avatar: avatarUrl });

  } catch (e) {
    return error(cors, "Database error: " + e.message, 500);
  }
}

async function verifyToken(req) {
  const authHeader = req.headers.get("Authorization");
  if (!authHeader) return null;
  try {
    const token = authHeader.split(" ")[1];
    const payload = JSON.parse(atob(token));
    if (payload.exp < Date.now()) return null;
    return { id: payload.uid };
  } catch (e) {
    return null;
  }
}

async function validateTurnstile(token, secretKey, ip) {
  const url = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';
  const formData = new FormData();
  formData.append('secret', secretKey);
  formData.append('response', token);
  if (ip) formData.append('remoteip', ip);

  try {
    const result = await fetch(url, {
      body: formData,
      method: 'POST',
    });

    const outcome = await result.json();
    return outcome.success;
  } catch (e) {
    console.error("Turnstile validation error:", e);
    return false;
  }
}